package io.github.arrayv.sorts.hybrid;

import io.github.arrayv.main.ArrayVisualizer;
import io.github.arrayv.sorts.templates.Sort;

// Copyright(c) 2018 Emura Daisuke
// MIT License

public final class HayateShiki extends Sort {
    public HayateShiki(ArrayVisualizer arrayVisualizer) {
        super(arrayVisualizer);

        this.setSortListName("Hayate-Shiki");
        this.setRunAllSortsName("Hayate-Shiki");
        this.setRunSortName("Hayate-Shiki");
        this.setCategory("Hybrid Sorts");
        this.setBucketSort(false);
        this.setRadixSort(false);
        this.setUnreasonablySlow(false);
        this.setUnreasonableLimit(0);
        this.setBogoSort(false);
    }

    // itr_t = int
    // dif_t = int

    private static int Bit(int v) {
        return (1 << v);
    }

    private static int cbIns = 5;
    private static int cnIns = Bit(cbIns);
    private int[] maExternal;

    /*
     * enum oRow {
     * oAsc,
     * oDsc,
     * oNum,
     * };
     */

    private final int oAsc = 0;
    private final int oDsc = 1;
    private final int oNum = 2;

    private class Part {
        int[] a = Writes.createExternalArray(3);
        int[] n = Writes.createExternalArray(3);
        int o;

        private void Delete() {
            Writes.deleteExternalArrays(a, n);
        }
    }

    private class Unit {
        int a;
        int n;
    }

    private static class Dive {
        Unit mUnit;
        int miJoin;
    }

    int Msb(int v) {
        return (int) (Math.log(v) / Math.log(2));
    }

    int MsbAlignment(int v) {
        return Msb(v + v - 1);
    }

    int LowerLimit(int v, int limit) {
        return (v > limit) ? v : limit;
    }

    int Copy(int iDst, int iSrc, int nSrc) {
        while (nSrc-- > 0) {
            iDst++;
            iDst = iSrc;
            iSrc++;

        }
        return iDst;
    }

    int Copy(int iDst, int iSrc, int nSrc, int v) {
        iDst = v;
        return Copy(++iDst, ++iSrc, --nSrc);
    }

    int Join(int iJoin, Unit rUnit, Part rPart) {
        int nDsc = rPart.n[oDsc];
        int nAsc = rPart.n[oAsc];

        rUnit.a = iJoin;
        rUnit.n = nDsc + nAsc;

        iJoin = Copy(iJoin, rPart.a[oDsc], nDsc);
        iJoin = Copy(iJoin, rPart.a[oAsc], nAsc);
        return iJoin;
    }

    int Join(int[] arr, int aJoin, Unit rUnit, Part rPart0, Part rPart1) {
        int iJoin = aJoin;
        int o0 = rPart0.o;
        int o1 = rPart1.o;
        int i0 = rPart0.a[o0];
        int i1 = rPart1.a[o1];
        int n0 = rPart0.n[o0];
        int n1 = rPart1.n[o1];
        int v0 = arr[i0];
        int v1 = arr[i1];

        while (true) {
            if (Reads.compareValues(v1, v0) > 0) {
                Writes.write(arr, iJoin++, v1, 1, true, false);
                if (--n1 > 0) {
                    v1 = arr[++i1];
                } else {
                    if (o1 > 0) {
                        o1 = oAsc;
                        i1 = rPart1.a[o1];
                        n1 = rPart1.n[o1];
                        v1 = arr[i1];
                    } else {
                        iJoin = Copy(iJoin, i1, n0, v0);
                        if (o0 > 0)
                            iJoin = Copy(iJoin, rPart0.a[oAsc], rPart0.n[oAsc]);
                        break;
                    }
                }
            } else {
                Writes.write(arr, iJoin++, v0, 1, true, false);
                if (--n0 > 0) {
                    v0 = arr[++i0];
                } else {
                    if (o0 > 0) {
                        o0 = oAsc;
                        i0 = rPart0.a[o0];
                        n0 = rPart0.n[o0];
                        v0 = arr[i0];
                    } else {
                        iJoin = Copy(iJoin, i1, n1, v1);
                        if (o1 > 0)
                            iJoin = Copy(iJoin, rPart1.a[oAsc], rPart1.n[oAsc]);
                        break;
                    }
                }
            }
        }
        rUnit.a = aJoin;
        rUnit.n = iJoin - aJoin;
        return iJoin;
    }

    int Join(int[] arr, int aJoin, Unit rUnit, Unit rUnit0, Unit rUnit1) {
        int iJoin = aJoin;
        int i0 = rUnit0.a;
        int i1 = rUnit1.a;
        int n0 = rUnit0.n;
        int n1 = rUnit1.n;
        int v0 = arr[i0];
        int v1 = arr[i1];

        while (true) {
            if (Reads.compareValues(v1, v0) > 0) {
                Writes.write(arr, iJoin++, v1, 1, true, false);
                if (--n1 > 0) {
                    v1 = arr[++i1];
                } else {
                    iJoin = Copy(iJoin, i0, n0, v0);
                    break;
                }
            } else {
                Writes.write(arr, iJoin++, v0, 1, true, false);
                if (--n0 > 0) {
                    v0 = arr[++i0];
                } else {
                    iJoin = Copy(iJoin, i1, n1, v1);
                    break;
                }
            }
        }
        rUnit.a = aJoin;
        rUnit.n = iJoin - aJoin;
        return iJoin;
    }

    int findRun(int[] array, int a, int b) {
        int i = a + 1;
        if (i == b)
            return i;
        if (Reads.compareIndices(array, i - 1, i++, 1, true) == 1) {
            while (i < b && Reads.compareIndices(array, i - 1, i, 1, true) == 1)
                i++;
            Writes.reversal(array, a, i - 1, 1, true, false);
        } else
            while (i < b && Reads.compareIndices(array, i - 1, i, 1, true) <= 0)
                i++;
        Highlights.clearMark(2);
        return i;
    }

    private int MakePart(int[] arr, Part rPart, int riSrc, int eSrc, int raDsc) {
        int iSrc = riSrc;
        int aAsc = iSrc;
        int eAsc = eSrc;
        int nSrc = eSrc - riSrc;
        if (nSrc > 1) {
            eAsc = findRun(arr, iSrc, nSrc);
        }

        int aDsc = raDsc;
        int eDsc = aDsc;

        int iOdd = eAsc;
        int nOdd = eSrc - iOdd;
        if (nOdd > 0) {
            if (Reads.compareValues(arr[iOdd], aAsc) > 0) {
                Writes.write(arr, --aDsc, arr[iOdd++], 1, true, false);

                while (--nOdd > 0) {
                    if (Reads.compareValues(arr[iOdd], eAsc - 1) > 0) {
                        if (Reads.compareValues(arr[iOdd], aDsc) > 0) {
                            Writes.write(arr, --aDsc, arr[iOdd++], 1, true, false);
                        } else {
                            break;
                        }
                    } else {
                        Writes.write(arr, eAsc++, arr[iOdd++], 1, true, false);
                    }
                }
            }
        }
        int nDsc = eDsc - aDsc;
        Writes.write(rPart.a, 0, aAsc, 1, false, true); // Part::oAsc
        Writes.write(rPart.n, 0, eAsc - aAsc, 1, false, true); // Part::oAsc
        Writes.write(rPart.a, 1, aDsc, 1, false, true); // Part::oDsc
        Writes.write(rPart.n, 1, nDsc, 1, false, true); // Part::oDsc
        rPart.o = (nDsc > 0) ? oDsc : oAsc;

        riSrc = iOdd;
        raDsc = aDsc;
        return nOdd;
    }

    private void Turn(int[] arr, int iDst, int iSrc, int nSrc) {
        iDst += nSrc;
        iSrc += nSrc;
        while (nSrc-- > 0)
            Writes.write(arr, --iDst, arr[--iSrc], 1, true, false);
    }

    private void Turn(int[] arr, Part rPart) {
        int nDsc = rPart.n[1];
        int nAsc = rPart.n[0];
        int aDsc = arr[0];
        int aAsc = aDsc + nDsc;

        if (nDsc > 0) {
            Turn(arr, aAsc, rPart.a[0], nAsc);
            Turn(arr, aDsc, rPart.a[1], nDsc);
        }
    }

    @Override
    public void runSort(int[] maOriginal, int mnOriginal, int bucketCount) {
        maExternal = Writes.createExternalArray(mnOriginal);
        int nDive = LowerLimit((MsbAlignment(mnOriginal) - cbIns), 1);
        Dive[] aDive = new Dive[nDive + 1];
        for (int i = 0; i < aDive.length; i++) {
            aDive[i] = new Dive();
        }
        for (int oDive = 0; oDive < nDive; ++oDive) {
            aDive[oDive].miJoin = (oDive & Bit(0)) > 0 ? maExternal[0] : maOriginal[0];
        }
        int nJoin = 0;

        int iJoin = maExternal[0];

        int iSrc = maOriginal[0];
        int eSrc = mnOriginal;
        while (iSrc != eSrc) {
            Unit vUnit = new Unit();

            Part vPart0 = new Part();
            Part vPart1 = new Part();
            int aDsc = maExternal.length;
            if (MakePart(maOriginal, vPart0, iSrc, eSrc, aDsc) > 0) {
                MakePart(maOriginal, vPart1, iSrc, eSrc, aDsc);
                iJoin = Join(maOriginal, iJoin, vUnit, vPart0, vPart1);
            } else {
                if (nJoin > 0) {
                    iJoin = Join(maOriginal, iJoin, vUnit, vPart0, vPart1);
                } else {
                    Turn(maOriginal, vPart0);
                    break;
                }
            }
            int Carry = nJoin++;
            Carry = (nJoin ^ Carry) & Carry;
            int i;
            for (i = 0; Carry > 0; Carry >>=1, ++i) {
                aDive[i].miJoin = Join(maOriginal, aDive[i].miJoin, vUnit, aDive[i].mUnit, vUnit);
            }
            aDive[i].mUnit = vUnit;
        }

        if (nJoin > 0) {
            int bJoin = nJoin & -nJoin;
            int oDive = Msb(bJoin);
            Dive pResult = aDive[oDive++];
            int Carry = nJoin ^ bJoin;
            Carry >>= oDive;
            for (int pDive = oDive; Carry > 0; Carry >>= 1, ++pDive) {
                if ((Carry & Bit(0)) > 0) {
                    Join(maOriginal, aDive[pDive].miJoin, pResult.mUnit, aDive[pDive].mUnit, pResult.mUnit);
                }
            }

            if (Reads.compareValues(pResult.mUnit.a, maExternal[0]) == 0)
            Copy(maOriginal[0], pResult.mUnit.a, pResult.mUnit.n);
        }
    }
}
